<!DOCTYPE html>
<html>
<head>
<title>Custom Elements: Custom element reactions must be invoked before returning to author scripts</title>
<meta name="author" title="Ryosuke Niwa" href="mailto:rniwa@webkit.org">
<meta name="assert" content="Custom element reactions must be invoked before returning to author scripts">
<link rel="help" href="https://html.spec.whatwg.org/multipage/scripting.html#invoke-custom-element-reactions">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
</head>
<body>
<infinite-cloning-element-1></infinite-cloning-element-1>
<infinite-cloning-element-2 id="a"></infinite-cloning-element-2>
<infinite-cloning-element-2 id="b"></infinite-cloning-element-2>
<div id="log"></div>
<script>

class MyCustomElement extends HTMLElement {
    attributeChangedCallback(...args) {
        this.handler(...args);
    }

    handler() { }
}
MyCustomElement.observedAttributes = ['data-title', 'title'];
customElements.define('my-custom-element', MyCustomElement);

test(function () {
    var instance = document.createElement('my-custom-element');
    var anotherInstance = document.createElement('my-custom-element');

    var callbackOrder = [];
    instance.handler = function () {
        callbackOrder.push([this, 'begin']);
        anotherInstance.setAttribute('data-title', 'baz');
        callbackOrder.push([this, 'end']);
    }
    anotherInstance.handler = function () {
        callbackOrder.push([this, 'begin']);
        callbackOrder.push([this, 'end']);
    }

    instance.setAttribute('title', 'foo');
    assert_equals(callbackOrder.length, 4);

    assert_array_equals(callbackOrder[0], [instance, 'begin']);
    assert_array_equals(callbackOrder[1], [anotherInstance, 'begin']);
    assert_array_equals(callbackOrder[2], [anotherInstance, 'end']);
    assert_array_equals(callbackOrder[3], [instance, 'end']);

}, 'setAttribute and removeAttribute must enqueue and invoke attributeChangedCallback');

test(function () {
    var instance = document.createElement('my-custom-element');
    var anotherInstance = document.createElement('my-custom-element');

    var callbackOrder = [];
    instance.handler = function () {
        callbackOrder.push([this, 'begin']);
        anotherInstance.toggleAttribute('data-title');
        callbackOrder.push([this, 'end']);
    }
    anotherInstance.handler = function () {
        callbackOrder.push([this, 'begin']);
        callbackOrder.push([this, 'end']);
    }

    instance.toggleAttribute('title');
    assert_equals(callbackOrder.length, 4);

    assert_array_equals(callbackOrder[0], [instance, 'begin']);
    assert_array_equals(callbackOrder[1], [anotherInstance, 'begin']);
    assert_array_equals(callbackOrder[2], [anotherInstance, 'end']);
    assert_array_equals(callbackOrder[3], [instance, 'end']);

}, 'toggleAttribute must enqueue and invoke attributeChangedCallback');

test(function () {
    var shouldCloneAnotherInstance = false;
    var anotherInstanceClone;
    var log = [];

    class SelfCloningElement extends HTMLElement {
        constructor() {
            super();
            log.push([this, 'begin']);
            if (shouldCloneAnotherInstance) {
                shouldCloneAnotherInstance = false;
                anotherInstanceClone = anotherInstance.cloneNode(false);
            }
            log.push([this, 'end']);
        }
    }
    customElements.define('self-cloning-element', SelfCloningElement);

    var instance = document.createElement('self-cloning-element');
    var anotherInstance = document.createElement('self-cloning-element');
    shouldCloneAnotherInstance = true;

    assert_equals(log.length, 4);
    var instanceClone = instance.cloneNode(false);

    assert_equals(log.length, 8);
    assert_array_equals(log[0], [instance, 'begin']);
    assert_array_equals(log[1], [instance, 'end']);
    assert_array_equals(log[2], [anotherInstance, 'begin']);
    assert_array_equals(log[3], [anotherInstance, 'end']);
    assert_array_equals(log[4], [instanceClone, 'begin']);
    assert_array_equals(log[5], [anotherInstanceClone, 'begin']);
    assert_array_equals(log[6], [anotherInstanceClone, 'end']);
    assert_array_equals(log[7], [instanceClone, 'end']);
}, 'Calling Node.prototype.cloneNode(false) must push a new element queue to the processing stack');

test(function () {
    var log = [];

    customElements.define('infinite-cloning-element-1',class extends HTMLElement {
        constructor() {
            super();
            log.push([this, 'begin']);
            // Potential infinite recursion:
            customElements.upgrade(this);
            log.push([this, 'end']);
        }
    });

    assert_equals(log.length, 2);
    const instance = document.querySelector("infinite-cloning-element-1");
    assert_array_equals(log[0], [instance, 'begin']);
    assert_array_equals(log[1], [instance, 'end']);
}, 'Infinite constructor recursion with upgrade(this) should not be possible');

test(function () {
    var log = [];

    customElements.define('infinite-cloning-element-2',class extends HTMLElement {
        constructor() {
            super();
            log.push([this, 'begin']);
            const b = document.querySelector("#b");
            b.remove();
            // While this constructor is running for "a", "b" is still
            // undefined, and so inserting it into the document will enqueue a
            // second upgrade reaction for "b" in addition to the one enqueued
            // by defining x-foo.
            document.body.appendChild(b);
            log.push([this, 'end']);
        }
    });

    assert_equals(log.length, 4);
    const instanceA = document.querySelector("#a");
    const instanceB = document.querySelector("#b");
    assert_array_equals(log[0], [instanceA, 'begin']);
    assert_array_equals(log[1], [instanceB, 'begin']);
    assert_array_equals(log[2], [instanceB, 'end']);
    assert_array_equals(log[3], [instanceA, 'end']);
}, 'Infinite constructor recursion with appendChild should not be possible');

</script>
</body>
</html>
