<!DOCTYPE html>
<meta charset=utf-8>
<title>Setting the current time of an animation</title>
<link rel="help" href="https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/web-animations/testcommon.js"></script>
<style>
.scroller {
  overflow: auto;
  height: 200px;
  width: 100px;
}
.contents {
  height: 1000px;
  width: 100%;
}
</style>
<body>
<div id="log"></div>
<script>
'use strict';

  function createScroller(test) {
    var scroller = createDiv(test);
    scroller.innerHTML = "<div class='contents'></div>";
    scroller.classList.add('scroller');
    return scroller;
  }

  function createScrollTimeline(test) {
    return new ScrollTimeline({
      scrollSource: createScroller(test),
      timeRange: 1000
    });
  }

  function createScrollLinkedAnimation(test, timeline) {
    if(timeline === undefined)
      timeline = createScrollTimeline(test);
    const DURATION = 1000; // ms
    const KEYFRAMES = { opacity: [1, 0] };
    return new Animation(
      new KeyframeEffect(createDiv(test), KEYFRAMES, DURATION), timeline);
  }

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    await animation.ready;

    // Set the current time to a valid value.
    const test_value = 333;
    animation.currentTime = test_value;
    assert_times_equal(
      animation.currentTime,
      test_value,
      "Animation current time should be equal to the set value."
    );
  }, 'Set animation current time to a valid value.');

  test(t => {
    const animation = createScrollLinkedAnimation(t);
    animation.play();
    const test_value = 250;
    animation.currentTime = test_value;

    assert_equals(animation.playState, "running");
    assert_true(animation.pending);
    assert_times_equal(animation.currentTime, test_value);
  }, 'Animation remains play pending after setting current time.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    await animation.ready;

    assert_throws(new TypeError(), () => {
      // Set the current time to null.
      animation.currentTime = null;
    });
  }, 'Setting animation current time to null throws TypeError.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    await animation.ready;

    // Set the current time to a valid value.
    const test_value = 333;
    animation.currentTime = test_value;
    assert_times_equal(
      animation.currentTime,
      test_value,
      "Animation current time should be equal to the set value."
    );
    // Cancel the animation and play it again, check that current time has reset
    // to scroll offset based current time.
    animation.cancel();
    animation.play();
    await animation.ready;

    assert_times_equal(
      animation.currentTime,
      animation.timeline.currentTime,
      "Animation current time should return to a value matching its" +
      " timeline current time after cancel/play is called."
    );
  }, 'Set animation.currentTime then cancel/play.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    await animation.ready;
    const originalCurrentTime = animation.currentTime;

    // Set the current time to something other than where the scroll offset.
    animation.currentTime = 500;

    // Setting current time is internally setting the start time to
    // scrollTimeline.currentTime - newAnimationCurrentTime.
    // Which results in current time of (timeline.currentTime - start_time).
    // This behavior puts the animation in a strange "out of sync" state between
    // the scroller and the animation effect, this is currently expected
    // behavior.

    const expectedStartTime = originalCurrentTime - animation.currentTime;
    assert_times_equal(
      animation.startTime,
      expectedStartTime,
      "Animation current time should be updated when setting the current time" +
      " to a time within the range of the animation.");

    scroller.scrollTop = 0.7 * maxScroll;

    assert_times_equal(
      animation.startTime,
      expectedStartTime,
      "Animation start time should remain unchanged when the scroller changes" +
      " position."
    );
    assert_times_equal(
      animation.currentTime,
      animation.timeline.currentTime - animation.startTime,
      "Animation current time should return to a value equal to" +
      " (timeline.currentTime - animation.startTime) after timeline scroll" +
      " source has been scrolled."
    );
  }, 'Set Animation current time then scroll.');

  promise_test(async t => {
    const animation = createScrollLinkedAnimation(t);
    const scroller = animation.timeline.scrollSource;
    const maxScroll = scroller.scrollHeight - scroller.clientHeight;
    scroller.scrollTop = 0.25 * maxScroll;
    animation.play();

    const test_value = 300;
    animation.currentTime = test_value;

    await animation.ready;

    assert_time_equals_literal(animation.currentTime, test_value);
  }, "Setting current time while play pending overrides the current time" +
     " obtained using the initial scroll offest.");
</script>
</body>
